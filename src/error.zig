const c = @cImport(@cInclude("wasmtime.h"));
const lib = @import("lib.zig");

// internal api
//
// NOTE: Is TLS the best solution here? If https://github.com/ziglang/zig/issues/2647 is
// implemented this 'global' API becomes unnecessary.
threadlocal var err: ?*Error = null;

// internal api
pub fn result(opt_err: ?*c.wasmtime_error_t) !void {
    if (opt_err) |new_err| {
        if (err) |e| {
            c.wasmtime_error_delete(@ptrCast(e));
        }
        err = @ptrCast(new_err);
        return error.WasmtimeError;
    }
}

// internal api
pub fn new(msg: [:0]const u8) *c.wasmtime_error_t {
    return c.wasmtime_error_new(msg);
}

/// Returns the latest `Error` generated by Wasmtime.
///
/// Instead of returning `Error`s from functions that generate them,
/// this library opts to return a zig error instead to maintain the
/// `try`/`catch` control flow. This function can then be used to retrieve
/// the original `Error` generated by Wasmtime.
///
/// This assumes an error has occurred. No error will result in a panic.
///
/// The caller owns the returned error, and must call `Error.delete`.
/// This function consumes the latest error, and as a result must not be called
/// again until a new error has occurred.
///
/// Threading: The latest `Error` is thread local, so different threads will
/// have their own latest `Error`.
pub fn consumeErr() *Error {
    if (err) |e| {
        err = null;
        return e;
    }
    @panic("No wasmtime error.");
}

/// Errors generated by Wasmtime.
///
/// Errors primarily have an error message associated with them
/// at this time, which you can acquire by calling `Error.message`.
///
/// Errors are safe to share across threads and must be deleted with
/// `Error.delete`.
pub const Error = opaque {
    /// Deletes an error.
    pub fn delete(e: *Error) void {
        c.wasmtime_error_delete(@ptrCast(e));
    }

    /// Returns the string description.
    ///
    /// This will "render" the error to a string and then return the string
    /// representation of the error to the caller.
    ///
    /// Caller owns the returned `Name` and must call `Name.delete` to free it.
    pub fn message(e: *Error) lib.Name {
        var m: lib.Name = undefined;
        c.wasmtime_error_message(@ptrCast(e), @ptrCast(&m));
        return m;
    }

    /// Attempts to extract a WASI-specific exit status.
    ///
    /// If the error is a WASI "exit" trap with a return status, then it is returned.
    /// Otherwise returns `null` to indicate that this is not a wasi exit trap.
    pub fn status(e: *Error) ?u32 {
        var code: c_int = undefined;
        c.wasmtime_error_exit_status(e, &code);
    }

    /// Attempts to extract a WebAssembly trace.
    ///
    /// If no trace is available it will return `null`.
    /// If not null, the caller must call `delete` to free the trace.
    pub fn trace(e: *Error) ?lib.FrameVec {
        var t: lib.FrameVec = undefined;
        c.wasmtime_error_wasm_trace(e, @ptrCast(&t));

        if (t.inner.size > 0) {
            return t;
        }

        t.delete();
        return null;
    }
};
